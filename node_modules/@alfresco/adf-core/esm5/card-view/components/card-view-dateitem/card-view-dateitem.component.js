/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, Input, ViewChild } from '@angular/core';
import { DateAdapter, MAT_DATE_FORMATS } from '@angular/material';
import { MatDatetimepicker, DatetimeAdapter, MAT_DATETIME_FORMATS } from '@mat-datetimepicker/core';
import { MomentDatetimeAdapter, MAT_MOMENT_DATETIME_FORMATS } from '@mat-datetimepicker/moment';
import moment from 'moment-es6';
import { CardViewDateItemModel } from '../../models/card-view-dateitem.model';
import { CardViewUpdateService } from '../../services/card-view-update.service';
import { UserPreferencesService, UserPreferenceValues } from '../../../services/user-preferences.service';
import { MomentDateAdapter } from '../../../utils/momentDateAdapter';
import { MOMENT_DATE_FORMATS } from '../../../utils/moment-date-formats.model';
import { AppConfigService } from '../../../app-config/app-config.service';
var ɵ0 = MOMENT_DATE_FORMATS, ɵ1 = MAT_MOMENT_DATETIME_FORMATS;
var CardViewDateItemComponent = /** @class */ (function () {
    function CardViewDateItemComponent(cardViewUpdateService, dateAdapter, userPreferencesService, appConfig) {
        this.cardViewUpdateService = cardViewUpdateService;
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.appConfig = appConfig;
        this.editable = false;
        this.displayEmpty = true;
        this.dateFormat = this.appConfig.get('dateValues.defaultDateFormat');
    }
    /**
     * @return {?}
     */
    CardViewDateItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.userPreferencesService.select(UserPreferenceValues.Locale).subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        function (locale) {
            _this.dateAdapter.setLocale(locale);
        }));
        ((/** @type {?} */ (this.dateAdapter))).overrideDisplayFormat = this.dateFormat;
        if (this.property.value) {
            this.valueDate = moment(this.property.value, this.dateFormat);
        }
    };
    /**
     * @return {?}
     */
    CardViewDateItemComponent.prototype.showProperty = /**
     * @return {?}
     */
    function () {
        return this.displayEmpty || !this.property.isEmpty();
    };
    /**
     * @return {?}
     */
    CardViewDateItemComponent.prototype.isEditable = /**
     * @return {?}
     */
    function () {
        return this.editable && this.property.editable;
    };
    /**
     * @return {?}
     */
    CardViewDateItemComponent.prototype.showDatePicker = /**
     * @return {?}
     */
    function () {
        this.datepicker.open();
    };
    /**
     * @param {?} newDateValue
     * @return {?}
     */
    CardViewDateItemComponent.prototype.onDateChanged = /**
     * @param {?} newDateValue
     * @return {?}
     */
    function (newDateValue) {
        if (newDateValue) {
            /** @type {?} */
            var momentDate = moment(newDateValue.value, this.dateFormat, true);
            if (momentDate.isValid()) {
                this.valueDate = momentDate;
                this.cardViewUpdateService.update(this.property, momentDate.toDate());
                this.property.value = momentDate.toDate();
            }
        }
    };
    CardViewDateItemComponent.decorators = [
        { type: Component, args: [{
                    providers: [
                        { provide: DateAdapter, useClass: MomentDateAdapter },
                        { provide: MAT_DATE_FORMATS, useValue: ɵ0 },
                        { provide: DatetimeAdapter, useClass: MomentDatetimeAdapter },
                        { provide: MAT_DATETIME_FORMATS, useValue: ɵ1 }
                    ],
                    selector: 'adf-card-view-dateitem',
                    template: "<div [attr.data-automation-id]=\"'card-dateitem-label-' + property.key\" class=\"adf-property-label\" *ngIf=\"showProperty() || isEditable()\">{{ property.label | translate }}</div>\n<div class=\"adf-property-value\">\n    <span *ngIf=\"!isEditable()\" [attr.data-automation-id]=\"'card-' + property.type + '-value-' + property.key\">\n        <span [attr.data-automation-id]=\"'card-dateitem-' + property.key\">\n            <span *ngIf=\"showProperty()\">{{ property.displayValue }}</span>\n        </span>\n    </span>\n    <div *ngIf=\"isEditable()\" class=\"adf-dateitem-editable\">\n        <div class=\"adf-dateitem-editable-controls\">\n            <span\n                class=\"adf-datepicker-toggle\"\n                [attr.data-automation-id]=\"'datepicker-label-toggle-' + property.key\"\n                (click)=\"showDatePicker()\">\n                <span [attr.data-automation-id]=\"'card-' + property.type + '-value-' + property.key\" *ngIf=\"showProperty(); else elseEmptyValueBlock\">{{ property.displayValue }}</span>\n            </span>\n            <mat-datetimepicker-toggle\n                [attr.title]=\"'CORE.METADATA.ACTIONS.EDIT' | translate\"\n                [attr.data-automation-id]=\"'datepickertoggle-' + property.key\"\n                [for]=\"datetimePicker\">\n            </mat-datetimepicker-toggle>\n        </div>\n\n        <input class=\"adf-invisible-date-input\"\n            [matDatetimepicker]=\"datetimePicker\"\n            [value]=\"valueDate\"\n            (dateChange)=\"onDateChanged($event)\">\n\n        <mat-datetimepicker #datetimePicker\n            [type]=\"property.type\"\n            timeInterval=\"5\"\n            [attr.data-automation-id]=\"'datepicker-' + property.key\"\n            [startAt]=\"valueDate\">\n        </mat-datetimepicker>\n    </div>\n    <ng-template #elseEmptyValueBlock>\n        {{ property.default | translate }}\n    </ng-template>\n</div>\n",
                    styles: [""]
                }] }
    ];
    /** @nocollapse */
    CardViewDateItemComponent.ctorParameters = function () { return [
        { type: CardViewUpdateService },
        { type: DateAdapter },
        { type: UserPreferencesService },
        { type: AppConfigService }
    ]; };
    CardViewDateItemComponent.propDecorators = {
        property: [{ type: Input }],
        editable: [{ type: Input }],
        displayEmpty: [{ type: Input }],
        datepicker: [{ type: ViewChild, args: ['datetimePicker',] }]
    };
    return CardViewDateItemComponent;
}());
export { CardViewDateItemComponent };
if (false) {
    /** @type {?} */
    CardViewDateItemComponent.prototype.property;
    /** @type {?} */
    CardViewDateItemComponent.prototype.editable;
    /** @type {?} */
    CardViewDateItemComponent.prototype.displayEmpty;
    /** @type {?} */
    CardViewDateItemComponent.prototype.datepicker;
    /** @type {?} */
    CardViewDateItemComponent.prototype.valueDate;
    /** @type {?} */
    CardViewDateItemComponent.prototype.dateFormat;
    /**
     * @type {?}
     * @private
     */
    CardViewDateItemComponent.prototype.cardViewUpdateService;
    /**
     * @type {?}
     * @private
     */
    CardViewDateItemComponent.prototype.dateAdapter;
    /**
     * @type {?}
     * @private
     */
    CardViewDateItemComponent.prototype.userPreferencesService;
    /**
     * @type {?}
     * @private
     */
    CardViewDateItemComponent.prototype.appConfig;
}
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FyZC12aWV3LWRhdGVpdGVtLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtY29yZS8iLCJzb3VyY2VzIjpbImNhcmQtdmlldy9jb21wb25lbnRzL2NhcmQtdmlldy1kYXRlaXRlbS9jYXJkLXZpZXctZGF0ZWl0ZW0uY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFVLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNwRSxPQUFPLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLGVBQWUsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3BHLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSwyQkFBMkIsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ2hHLE9BQU8sTUFBTSxNQUFNLFlBQVksQ0FBQztBQUVoQyxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQztBQUM5RSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQztBQUNoRixPQUFPLEVBQUUsc0JBQXNCLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSw0Q0FBNEMsQ0FBQztBQUMxRyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUNyRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQztBQUMvRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx3Q0FBd0MsQ0FBQztTQUszQixtQkFBbUIsT0FFZiwyQkFBMkI7QUFMOUU7SUE0QkksbUNBQW9CLHFCQUE0QyxFQUM1QyxXQUFnQyxFQUNoQyxzQkFBOEMsRUFDOUMsU0FBMkI7UUFIM0IsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUF1QjtRQUM1QyxnQkFBVyxHQUFYLFdBQVcsQ0FBcUI7UUFDaEMsMkJBQXNCLEdBQXRCLHNCQUFzQixDQUF3QjtRQUM5QyxjQUFTLEdBQVQsU0FBUyxDQUFrQjtRQWQvQyxhQUFRLEdBQVksS0FBSyxDQUFDO1FBRzFCLGlCQUFZLEdBQVksSUFBSSxDQUFDO1FBWXpCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsOEJBQThCLENBQUMsQ0FBQztJQUN6RSxDQUFDOzs7O0lBRUQsNENBQVE7OztJQUFSO1FBQUEsaUJBVUM7UUFURyxJQUFJLENBQUMsc0JBQXNCLENBQUMsTUFBTSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxDQUFDLFNBQVM7Ozs7UUFBQyxVQUFDLE1BQU07WUFDN0UsS0FBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkMsQ0FBQyxFQUFDLENBQUM7UUFFSCxDQUFDLG1CQUFvQixJQUFJLENBQUMsV0FBVyxFQUFBLENBQUMsQ0FBQyxxQkFBcUIsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBRS9FLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUU7WUFDckIsSUFBSSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ2pFO0lBQ0wsQ0FBQzs7OztJQUVELGdEQUFZOzs7SUFBWjtRQUNJLE9BQU8sSUFBSSxDQUFDLFlBQVksSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDekQsQ0FBQzs7OztJQUVELDhDQUFVOzs7SUFBVjtRQUNJLE9BQU8sSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQztJQUNuRCxDQUFDOzs7O0lBRUQsa0RBQWM7OztJQUFkO1FBQ0ksSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUMzQixDQUFDOzs7OztJQUVELGlEQUFhOzs7O0lBQWIsVUFBYyxZQUFZO1FBQ3RCLElBQUksWUFBWSxFQUFFOztnQkFDUixVQUFVLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUM7WUFDcEUsSUFBSSxVQUFVLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQ3RCLElBQUksQ0FBQyxTQUFTLEdBQUcsVUFBVSxDQUFDO2dCQUM1QixJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7Z0JBQ3RFLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxHQUFHLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQzthQUM3QztTQUNKO0lBQ0wsQ0FBQzs7Z0JBcEVKLFNBQVMsU0FBQztvQkFDUCxTQUFTLEVBQUU7d0JBQ1AsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBRTt3QkFDckQsRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxJQUFxQixFQUFFO3dCQUM1RCxFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsUUFBUSxFQUFFLHFCQUFxQixFQUFFO3dCQUM3RCxFQUFFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxRQUFRLElBQTZCLEVBQUU7cUJBQzNFO29CQUNELFFBQVEsRUFBRSx3QkFBd0I7b0JBQ2xDLHk1REFBa0Q7O2lCQUVyRDs7OztnQkFoQlEscUJBQXFCO2dCQU5yQixXQUFXO2dCQU9YLHNCQUFzQjtnQkFHdEIsZ0JBQWdCOzs7MkJBZXBCLEtBQUs7MkJBR0wsS0FBSzsrQkFHTCxLQUFLOzZCQUdMLFNBQVMsU0FBQyxnQkFBZ0I7O0lBZ0QvQixnQ0FBQztDQUFBLEFBdEVELElBc0VDO1NBM0RZLHlCQUF5Qjs7O0lBRWxDLDZDQUNnQzs7SUFFaEMsNkNBQzBCOztJQUUxQixpREFDNkI7O0lBRTdCLCtDQUMwQzs7SUFFMUMsOENBQWtCOztJQUNsQiwrQ0FBbUI7Ozs7O0lBRVAsMERBQW9EOzs7OztJQUNwRCxnREFBd0M7Ozs7O0lBQ3hDLDJEQUFzRDs7Ozs7SUFDdEQsOENBQW1DIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25Jbml0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERhdGVBZGFwdGVyLCBNQVRfREFURV9GT1JNQVRTIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgTWF0RGF0ZXRpbWVwaWNrZXIsIERhdGV0aW1lQWRhcHRlciwgTUFUX0RBVEVUSU1FX0ZPUk1BVFMgfSBmcm9tICdAbWF0LWRhdGV0aW1lcGlja2VyL2NvcmUnO1xuaW1wb3J0IHsgTW9tZW50RGF0ZXRpbWVBZGFwdGVyLCBNQVRfTU9NRU5UX0RBVEVUSU1FX0ZPUk1BVFMgfSBmcm9tICdAbWF0LWRhdGV0aW1lcGlja2VyL21vbWVudCc7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudC1lczYnO1xuaW1wb3J0IHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB7IENhcmRWaWV3RGF0ZUl0ZW1Nb2RlbCB9IGZyb20gJy4uLy4uL21vZGVscy9jYXJkLXZpZXctZGF0ZWl0ZW0ubW9kZWwnO1xuaW1wb3J0IHsgQ2FyZFZpZXdVcGRhdGVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY2FyZC12aWV3LXVwZGF0ZS5zZXJ2aWNlJztcbmltcG9ydCB7IFVzZXJQcmVmZXJlbmNlc1NlcnZpY2UsIFVzZXJQcmVmZXJlbmNlVmFsdWVzIH0gZnJvbSAnLi4vLi4vLi4vc2VydmljZXMvdXNlci1wcmVmZXJlbmNlcy5zZXJ2aWNlJztcbmltcG9ydCB7IE1vbWVudERhdGVBZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbW9tZW50RGF0ZUFkYXB0ZXInO1xuaW1wb3J0IHsgTU9NRU5UX0RBVEVfRk9STUFUUyB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL21vbWVudC1kYXRlLWZvcm1hdHMubW9kZWwnO1xuaW1wb3J0IHsgQXBwQ29uZmlnU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL2FwcC1jb25maWcvYXBwLWNvbmZpZy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHsgcHJvdmlkZTogRGF0ZUFkYXB0ZXIsIHVzZUNsYXNzOiBNb21lbnREYXRlQWRhcHRlciB9LFxuICAgICAgICB7IHByb3ZpZGU6IE1BVF9EQVRFX0ZPUk1BVFMsIHVzZVZhbHVlOiBNT01FTlRfREFURV9GT1JNQVRTIH0sXG4gICAgICAgIHsgcHJvdmlkZTogRGF0ZXRpbWVBZGFwdGVyLCB1c2VDbGFzczogTW9tZW50RGF0ZXRpbWVBZGFwdGVyIH0sXG4gICAgICAgIHsgcHJvdmlkZTogTUFUX0RBVEVUSU1FX0ZPUk1BVFMsIHVzZVZhbHVlOiBNQVRfTU9NRU5UX0RBVEVUSU1FX0ZPUk1BVFMgfVxuICAgIF0sXG4gICAgc2VsZWN0b3I6ICdhZGYtY2FyZC12aWV3LWRhdGVpdGVtJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vY2FyZC12aWV3LWRhdGVpdGVtLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9jYXJkLXZpZXctZGF0ZWl0ZW0uY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBDYXJkVmlld0RhdGVJdGVtQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIEBJbnB1dCgpXG4gICAgcHJvcGVydHk6IENhcmRWaWV3RGF0ZUl0ZW1Nb2RlbDtcblxuICAgIEBJbnB1dCgpXG4gICAgZWRpdGFibGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpXG4gICAgZGlzcGxheUVtcHR5OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIEBWaWV3Q2hpbGQoJ2RhdGV0aW1lUGlja2VyJylcbiAgICBwdWJsaWMgZGF0ZXBpY2tlcjogTWF0RGF0ZXRpbWVwaWNrZXI8YW55PjtcblxuICAgIHZhbHVlRGF0ZTogTW9tZW50O1xuICAgIGRhdGVGb3JtYXQ6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY2FyZFZpZXdVcGRhdGVTZXJ2aWNlOiBDYXJkVmlld1VwZGF0ZVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBkYXRlQWRhcHRlcjogRGF0ZUFkYXB0ZXI8TW9tZW50PixcbiAgICAgICAgICAgICAgICBwcml2YXRlIHVzZXJQcmVmZXJlbmNlc1NlcnZpY2U6IFVzZXJQcmVmZXJlbmNlc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBhcHBDb25maWc6IEFwcENvbmZpZ1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5kYXRlRm9ybWF0ID0gdGhpcy5hcHBDb25maWcuZ2V0KCdkYXRlVmFsdWVzLmRlZmF1bHREYXRlRm9ybWF0Jyk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMudXNlclByZWZlcmVuY2VzU2VydmljZS5zZWxlY3QoVXNlclByZWZlcmVuY2VWYWx1ZXMuTG9jYWxlKS5zdWJzY3JpYmUoKGxvY2FsZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kYXRlQWRhcHRlci5zZXRMb2NhbGUobG9jYWxlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgKDxNb21lbnREYXRlQWRhcHRlcj4gdGhpcy5kYXRlQWRhcHRlcikub3ZlcnJpZGVEaXNwbGF5Rm9ybWF0ID0gdGhpcy5kYXRlRm9ybWF0O1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnR5LnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlRGF0ZSA9IG1vbWVudCh0aGlzLnByb3BlcnR5LnZhbHVlLCB0aGlzLmRhdGVGb3JtYXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2hvd1Byb3BlcnR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5RW1wdHkgfHwgIXRoaXMucHJvcGVydHkuaXNFbXB0eSgpO1xuICAgIH1cblxuICAgIGlzRWRpdGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRhYmxlICYmIHRoaXMucHJvcGVydHkuZWRpdGFibGU7XG4gICAgfVxuXG4gICAgc2hvd0RhdGVQaWNrZXIoKSB7XG4gICAgICAgIHRoaXMuZGF0ZXBpY2tlci5vcGVuKCk7XG4gICAgfVxuXG4gICAgb25EYXRlQ2hhbmdlZChuZXdEYXRlVmFsdWUpIHtcbiAgICAgICAgaWYgKG5ld0RhdGVWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgbW9tZW50RGF0ZSA9IG1vbWVudChuZXdEYXRlVmFsdWUudmFsdWUsIHRoaXMuZGF0ZUZvcm1hdCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAobW9tZW50RGF0ZS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlRGF0ZSA9IG1vbWVudERhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXJkVmlld1VwZGF0ZVNlcnZpY2UudXBkYXRlKHRoaXMucHJvcGVydHksIG1vbWVudERhdGUudG9EYXRlKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHkudmFsdWUgPSBtb21lbnREYXRlLnRvRGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG4iXX0=