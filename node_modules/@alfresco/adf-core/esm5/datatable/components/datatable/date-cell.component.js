/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ViewEncapsulation } from '@angular/core';
import { DataTableCellComponent } from './datatable-cell.component';
import { UserPreferencesService, UserPreferenceValues } from '../../../services/user-preferences.service';
import { AlfrescoApiService } from '../../../services/alfresco-api.service';
import { AppConfigService } from '../../../app-config/app-config.service';
var DateCellComponent = /** @class */ (function (_super) {
    tslib_1.__extends(DateCellComponent, _super);
    function DateCellComponent(userPreferenceService, alfrescoApiService, appConfig) {
        var _this = _super.call(this, alfrescoApiService) || this;
        _this.dateFormat = appConfig.get('dateValues.defaultDateFormat', DateCellComponent.DATE_FORMAT);
        if (userPreferenceService) {
            userPreferenceService
                .select(UserPreferenceValues.Locale)
                .subscribe((/**
             * @param {?} locale
             * @return {?}
             */
            function (locale) {
                _this.currentLocale = locale;
            }));
        }
        return _this;
    }
    Object.defineProperty(DateCellComponent.prototype, "format", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.column) {
                return this.column.format || this.dateFormat;
            }
            return this.dateFormat;
        },
        enumerable: true,
        configurable: true
    });
    DateCellComponent.DATE_FORMAT = 'medium';
    DateCellComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-date-cell',
                    template: "\n        <ng-container>\n            <span\n                [attr.aria-label]=\"value$ | async | adfTimeAgo: currentLocale\"\n                title=\"{{ tooltip | adfLocalizedDate: 'medium' }}\"\n                class=\"adf-datatable-cell-value\"\n                *ngIf=\"format === 'timeAgo'; else standard_date\">\n                {{ value$ | async | adfTimeAgo: currentLocale }}\n            </span>\n        </ng-container>\n        <ng-template #standard_date>\n            <span\n                class=\"adf-datatable-cell-value\"\n                title=\"{{ tooltip | adfLocalizedDate: format }}\"\n                class=\"adf-datatable-cell-value\"\n                [attr.aria-label]=\"value$ | async | adfLocalizedDate: format\">\n                {{ value$ | async | adfLocalizedDate: format }}\n            </span>\n        </ng-template>\n    ",
                    encapsulation: ViewEncapsulation.None,
                    host: { class: 'adf-date-cell adf-datatable-content-cell' }
                }] }
    ];
    /** @nocollapse */
    DateCellComponent.ctorParameters = function () { return [
        { type: UserPreferencesService },
        { type: AlfrescoApiService },
        { type: AppConfigService }
    ]; };
    return DateCellComponent;
}(DataTableCellComponent));
export { DateCellComponent };
if (false) {
    /** @type {?} */
    DateCellComponent.DATE_FORMAT;
    /** @type {?} */
    DateCellComponent.prototype.currentLocale;
    /** @type {?} */
    DateCellComponent.prototype.dateFormat;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1jZWxsLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtY29yZS8iLCJzb3VyY2VzIjpbImRhdGF0YWJsZS9jb21wb25lbnRzL2RhdGF0YWJsZS9kYXRlLWNlbGwuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxPQUFPLEVBQUUsU0FBUyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3BFLE9BQU8sRUFDSCxzQkFBc0IsRUFDdEIsb0JBQW9CLEVBQ3ZCLE1BQU0sNENBQTRDLENBQUM7QUFDcEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFDNUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFFMUU7SUEwQnVDLDZDQUFzQjtJQWN6RCwyQkFDSSxxQkFBNkMsRUFDN0Msa0JBQXNDLEVBQ3RDLFNBQTJCO1FBSC9CLFlBS0ksa0JBQU0sa0JBQWtCLENBQUMsU0FVNUI7UUFSRyxLQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsOEJBQThCLEVBQUUsaUJBQWlCLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDL0YsSUFBSSxxQkFBcUIsRUFBRTtZQUN2QixxQkFBcUI7aUJBQ2hCLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUM7aUJBQ25DLFNBQVM7Ozs7WUFBQyxVQUFDLE1BQU07Z0JBQ2QsS0FBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUM7WUFDaEMsQ0FBQyxFQUFDLENBQUM7U0FDVjs7SUFDTCxDQUFDO0lBdEJELHNCQUFJLHFDQUFNOzs7O1FBQVY7WUFDSSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7Z0JBQ2IsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDO2FBQ2hEO1lBQ0QsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQzNCLENBQUM7OztPQUFBO0lBVk0sNkJBQVcsR0FBRyxRQUFRLENBQUM7O2dCQTVCakMsU0FBUyxTQUFDO29CQUNQLFFBQVEsRUFBRSxlQUFlO29CQUV6QixRQUFRLEVBQUUseTFCQW1CVDtvQkFDRCxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtvQkFDckMsSUFBSSxFQUFFLEVBQUUsS0FBSyxFQUFFLDBDQUEwQyxFQUFFO2lCQUM5RDs7OztnQkEvQkcsc0JBQXNCO2dCQUdqQixrQkFBa0I7Z0JBQ2xCLGdCQUFnQjs7SUEwRHpCLHdCQUFDO0NBQUEsQUF4REQsQ0EwQnVDLHNCQUFzQixHQThCNUQ7U0E5QlksaUJBQWlCOzs7SUFFMUIsOEJBQThCOztJQUU5QiwwQ0FBc0I7O0lBQ3RCLHVDQUFtQiIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERhdGFUYWJsZUNlbGxDb21wb25lbnQgfSBmcm9tICcuL2RhdGF0YWJsZS1jZWxsLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIFVzZXJQcmVmZXJlbmNlc1NlcnZpY2UsXG4gICAgVXNlclByZWZlcmVuY2VWYWx1ZXNcbn0gZnJvbSAnLi4vLi4vLi4vc2VydmljZXMvdXNlci1wcmVmZXJlbmNlcy5zZXJ2aWNlJztcbmltcG9ydCB7IEFsZnJlc2NvQXBpU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZpY2VzL2FsZnJlc2NvLWFwaS5zZXJ2aWNlJztcbmltcG9ydCB7IEFwcENvbmZpZ1NlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9hcHAtY29uZmlnL2FwcC1jb25maWcuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWRhdGUtY2VsbCcsXG5cbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyPlxuICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cInZhbHVlJCB8IGFzeW5jIHwgYWRmVGltZUFnbzogY3VycmVudExvY2FsZVwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJ7eyB0b29sdGlwIHwgYWRmTG9jYWxpemVkRGF0ZTogJ21lZGl1bScgfX1cIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiYWRmLWRhdGF0YWJsZS1jZWxsLXZhbHVlXCJcbiAgICAgICAgICAgICAgICAqbmdJZj1cImZvcm1hdCA9PT0gJ3RpbWVBZ28nOyBlbHNlIHN0YW5kYXJkX2RhdGVcIj5cbiAgICAgICAgICAgICAgICB7eyB2YWx1ZSQgfCBhc3luYyB8IGFkZlRpbWVBZ286IGN1cnJlbnRMb2NhbGUgfX1cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjc3RhbmRhcmRfZGF0ZT5cbiAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJhZGYtZGF0YXRhYmxlLWNlbGwtdmFsdWVcIlxuICAgICAgICAgICAgICAgIHRpdGxlPVwie3sgdG9vbHRpcCB8IGFkZkxvY2FsaXplZERhdGU6IGZvcm1hdCB9fVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJhZGYtZGF0YXRhYmxlLWNlbGwtdmFsdWVcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwidmFsdWUkIHwgYXN5bmMgfCBhZGZMb2NhbGl6ZWREYXRlOiBmb3JtYXRcIj5cbiAgICAgICAgICAgICAgICB7eyB2YWx1ZSQgfCBhc3luYyB8IGFkZkxvY2FsaXplZERhdGU6IGZvcm1hdCB9fVxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGAsXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBob3N0OiB7IGNsYXNzOiAnYWRmLWRhdGUtY2VsbCBhZGYtZGF0YXRhYmxlLWNvbnRlbnQtY2VsbCcgfVxufSlcbmV4cG9ydCBjbGFzcyBEYXRlQ2VsbENvbXBvbmVudCBleHRlbmRzIERhdGFUYWJsZUNlbGxDb21wb25lbnQge1xuXG4gICAgc3RhdGljIERBVEVfRk9STUFUID0gJ21lZGl1bSc7XG5cbiAgICBjdXJyZW50TG9jYWxlOiBzdHJpbmc7XG4gICAgZGF0ZUZvcm1hdDogc3RyaW5nO1xuXG4gICAgZ2V0IGZvcm1hdCgpOiBzdHJpbmcge1xuICAgICAgICBpZiAodGhpcy5jb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbi5mb3JtYXQgfHwgdGhpcy5kYXRlRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVGb3JtYXQ7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHVzZXJQcmVmZXJlbmNlU2VydmljZTogVXNlclByZWZlcmVuY2VzU2VydmljZSxcbiAgICAgICAgYWxmcmVzY29BcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgIGFwcENvbmZpZzogQXBwQ29uZmlnU2VydmljZVxuICAgICkge1xuICAgICAgICBzdXBlcihhbGZyZXNjb0FwaVNlcnZpY2UpO1xuXG4gICAgICAgIHRoaXMuZGF0ZUZvcm1hdCA9IGFwcENvbmZpZy5nZXQoJ2RhdGVWYWx1ZXMuZGVmYXVsdERhdGVGb3JtYXQnLCBEYXRlQ2VsbENvbXBvbmVudC5EQVRFX0ZPUk1BVCk7XG4gICAgICAgIGlmICh1c2VyUHJlZmVyZW5jZVNlcnZpY2UpIHtcbiAgICAgICAgICAgIHVzZXJQcmVmZXJlbmNlU2VydmljZVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoVXNlclByZWZlcmVuY2VWYWx1ZXMuTG9jYWxlKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKGxvY2FsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRMb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=